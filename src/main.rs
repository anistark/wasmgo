#[cfg(feature = "cli")]
use clap::{Parser, Subcommand};
use wasmgo::{CompileConfig, OptimizationLevel, Plugin, TargetType, WasmGoPlugin};

#[cfg(feature = "cli")]
#[derive(Parser)]
#[command(name = "wasmgo")]
#[command(about = "Go WebAssembly plugin for Wasmrun")]
#[command(version)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[cfg(feature = "cli")]
#[derive(Subcommand)]
enum Commands {
    /// Run a Go WebAssembly project for execution (default command)
    #[command(alias = "r")]
    Run {
        /// Project path containing go.mod or main.go
        #[arg(short, long, default_value = ".", value_name = "PATH")]
        project: String,

        /// Output directory for compiled files
        #[arg(short, long, default_value = "./dist", value_name = "DIR")]
        output: String,

        /// Optimization level for compilation
        #[arg(long, value_enum, default_value = "release")]
        optimization: CliOptimization,

        /// Enable verbose compilation output
        #[arg(short, long)]
        verbose: bool,
    },

    /// Compile a Go project to WebAssembly
    #[command(alias = "c")]
    Compile {
        /// Project path containing go.mod or main.go
        #[arg(short, long, default_value = ".", value_name = "PATH")]
        project: String,

        /// Output directory for compiled files
        #[arg(short, long, default_value = "./dist", value_name = "DIR")]
        output: String,

        /// Optimization level for compilation
        #[arg(long, value_enum, default_value = "release")]
        optimization: CliOptimization,

        /// Target type for compilation
        #[arg(long, value_enum, default_value = "wasm")]
        target: CliTarget,

        /// Enable verbose compilation output
        #[arg(short, long)]
        verbose: bool,
    },

    /// Inspect project structure, dependencies, and frameworks
    #[command(alias = "check")]
    Inspect {
        /// Project path to inspect
        #[arg(short, long, default_value = ".", value_name = "PATH")]
        project: String,
    },

    /// Check if wasmgo can handle the project
    CanHandle {
        /// Project path to check
        #[arg(value_name = "PATH")]
        project: String,
    },

    /// Check dependencies and system requirements
    CheckDeps,

    /// Clean build artifacts
    Clean {
        /// Project path to clean
        #[arg(value_name = "PATH")]
        project: String,
    },

    /// Show plugin information and capabilities
    Info,

    /// Show supported frameworks and project types
    Frameworks,
}

#[cfg(feature = "cli")]
#[derive(clap::ValueEnum, Clone, Debug)]
enum CliOptimization {
    /// Fast compilation with debug symbols
    Debug,
    /// Balanced optimization for production
    Release,
    /// Smallest possible output size
    Size,
}

#[cfg(feature = "cli")]
#[derive(clap::ValueEnum, Clone, Debug)]
enum CliTarget {
    /// Standard WebAssembly module
    Wasm,
    /// Complete web application bundle
    WebApp,
}

#[cfg(feature = "cli")]
impl From<CliOptimization> for OptimizationLevel {
    fn from(opt: CliOptimization) -> Self {
        match opt {
            CliOptimization::Debug => OptimizationLevel::Debug,
            CliOptimization::Release => OptimizationLevel::Release,
            CliOptimization::Size => OptimizationLevel::Size,
        }
    }
}

#[cfg(feature = "cli")]
impl From<CliTarget> for TargetType {
    fn from(target: CliTarget) -> Self {
        match target {
            CliTarget::Wasm => TargetType::Standard,
            CliTarget::WebApp => TargetType::WebApp,
        }
    }
}

#[cfg(feature = "cli")]
fn print_header() {
    println!(
        "üêπ {} v{}",
        env!("CARGO_PKG_NAME"),
        env!("CARGO_PKG_VERSION")
    );
    println!("   {}", env!("CARGO_PKG_DESCRIPTION"));
    println!();
}

#[cfg(feature = "cli")]
fn check_project_validity(plugin: &WasmGoPlugin, project: &str) -> bool {
    if !plugin.can_handle_project(project) {
        eprintln!("‚ùå Error: Not a valid Go project");
        eprintln!("   Looking for go.mod or .go files in: {project}");
        eprintln!("   Make sure you're in a Go project directory");
        return false;
    }
    true
}

#[cfg(feature = "cli")]
fn check_dependencies(plugin: &WasmGoPlugin) -> bool {
    let missing_deps = plugin.get_builder().check_dependencies();
    if !missing_deps.is_empty() {
        eprintln!("‚ùå Missing required dependencies:");
        for dep in &missing_deps {
            eprintln!("   ‚Ä¢ {dep}");
        }
        eprintln!();
        eprintln!("üí° Installation suggestions:");
        if missing_deps.iter().any(|d| d.contains("go")) {
            eprintln!("   ‚Ä¢ Install Go: https://golang.org/dl/");
        }
        if missing_deps.iter().any(|d| d.contains("tinygo")) {
            eprintln!("   ‚Ä¢ Install TinyGo: https://tinygo.org/getting-started/install/");
        }
        return false;
    }
    true
}

#[cfg(feature = "cli")]
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();
    let plugin = WasmGoPlugin::new();

    // Default to Run command if no subcommand is provided
    // Note: this would require making command optional in Cli struct
    match cli.command {
        Commands::Run {
            project,
            output,
            optimization,
            verbose,
        } => {
            if verbose {
                print_header();
                println!("üöÄ Preparing Go project for execution...");
                println!("üìÅ Project: {project}");
                println!("üì¶ Output: {output}");
                println!("üéØ Optimization: {optimization:?}");
                println!();
            }

            if !check_project_validity(&plugin, &project) {
                std::process::exit(1);
            }

            if !check_dependencies(&plugin) {
                std::process::exit(1);
            }

            let builder = plugin.get_builder();
            let compile_config = CompileConfig {
                project_path: project.clone(),
                output_directory: output,
                verbose,
                optimization_level: optimization.into(),
                target_type: TargetType::Standard,
            };

            match builder.compile(&compile_config) {
                Ok(result) => {
                    if verbose {
                        println!("‚úÖ Project ready for execution!");
                        println!("üéØ Entry point: {}", result.wasm_file_path);
                    } else {
                        println!("{}", result.wasm_file_path);
                    }
                }
                Err(e) => {
                    eprintln!("‚ùå Failed to prepare project for execution: {e}");
                    std::process::exit(1);
                }
            }
        }

        Commands::Compile {
            project,
            output,
            optimization,
            target,
            verbose,
        } => {
            if verbose {
                print_header();
                println!("üî® Compiling Go project to WebAssembly...");
                println!("üìÅ Project: {project}");
                println!("üì¶ Output: {output}");
                println!("üéØ Optimization: {optimization:?}");
                println!("üèóÔ∏è  Target: {target:?}");
                println!();
            }

            if !check_project_validity(&plugin, &project) {
                std::process::exit(1);
            }

            if !check_dependencies(&plugin) {
                std::process::exit(1);
            }

            let builder = plugin.get_builder();
            let compile_config = CompileConfig {
                project_path: project.clone(),
                output_directory: output,
                verbose,
                optimization_level: optimization.into(),
                target_type: target.into(),
            };

            match builder.compile(&compile_config) {
                Ok(result) => {
                    println!("‚úÖ Compilation completed successfully!");
                    println!("üéØ WASM file: {}", result.wasm_file_path);

                    if let Some(js_path) = result.js_file_path {
                        println!("üìÑ JS bindings: {js_path}");
                    }

                    if !result.additional_files.is_empty() {
                        println!("üìÇ Additional files: {}", result.additional_files.len());
                        if verbose {
                            for file in result.additional_files {
                                println!("   ‚Ä¢ {file}");
                            }
                        }
                    }
                }
                Err(e) => {
                    eprintln!("‚ùå Compilation failed: {e}");
                    std::process::exit(1);
                }
            }
        }

        Commands::Inspect { project } => {
            print_header();
            println!("üîç Inspecting Go project...");
            println!();

            if plugin.can_handle_project(&project) {
                println!("üìä Project Analysis");
                println!("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");

                if let Ok(directory_entries) = std::fs::read_dir(&project) {
                    let go_files: Vec<_> = directory_entries
                        .filter_map(|entry| entry.ok())
                        .filter(|entry| {
                            entry
                                .path()
                                .extension()
                                .map(|extension| extension.to_string_lossy().to_lowercase() == "go")
                                .unwrap_or(false)
                        })
                        .map(|entry| entry.file_name().to_string_lossy().to_string())
                        .collect();

                    if !go_files.is_empty() {
                        println!("üìÅ Go files: {}", go_files.join(", "));
                    }
                }

                if std::path::Path::new(&project).join("go.mod").exists() {
                    println!("üì¶ Module: Found go.mod");
                }

                println!("üéØ Type: Go WebAssembly project");
                println!("üîß Build Tool: TinyGo");

                println!();
                println!("üìã Dependencies");
                println!("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");

                let missing = plugin.get_builder().check_dependencies();
                if missing.is_empty() {
                    println!("‚úÖ go - Go compiler");
                    println!("‚úÖ tinygo - WebAssembly compiler for Go");
                    println!();
                    println!("üéâ Project is ready to compile!");
                } else {
                    for dep in &missing {
                        println!("‚ùå {dep}");
                    }
                    println!();
                    println!(
                        "‚ö†Ô∏è  Some required dependencies are missing. Install them to proceed."
                    );
                    std::process::exit(1);
                }
            } else {
                eprintln!("‚ùå Invalid project: Not a Go project");
                eprintln!("   Looking for go.mod or .go files in: {project}");
                std::process::exit(1);
            }
        }

        Commands::CanHandle { project } => {
            if plugin.can_handle_project(&project) {
                println!("‚úÖ Yes, wasmgo can handle this project");
                if std::path::Path::new(&project).join("go.mod").exists() {
                    println!("üìÅ Found go.mod at: {project}/go.mod");
                } else {
                    println!("üìÅ Found Go files in: {project}");
                }
            } else {
                println!("‚ùå No, wasmgo cannot handle this project");
                println!("üîç Looking for go.mod or .go files in: {project}");
                std::process::exit(1);
            }
        }

        Commands::CheckDeps => {
            print_header();
            println!("üîç Checking system dependencies...");
            println!();

            let missing = plugin.get_builder().check_dependencies();

            if missing.is_empty() {
                println!("‚úÖ All required dependencies are available!");
                println!();
                println!("üìã Available tools:");
                println!("   ‚úÖ go - Go compiler");
                println!("   ‚úÖ tinygo - WebAssembly compiler for Go");
            } else {
                println!("‚ùå Missing required dependencies:");
                for dep in &missing {
                    println!("   ‚Ä¢ {dep}");
                }

                println!();
                println!("üí° Installation suggestions:");
                println!("   ‚Ä¢ Install Go: https://golang.org/dl/");
                println!("   ‚Ä¢ Install TinyGo: https://tinygo.org/getting-started/install/");
                println!("   ‚Ä¢ On macOS with Homebrew: brew install go tinygo");
                println!("   ‚Ä¢ On Ubuntu/Debian: sudo apt install golang-go && follow TinyGo instructions");

                std::process::exit(1);
            }
        }

        Commands::Clean { project } => {
            println!("üßπ Cleaning project artifacts: {project}");

            // For Go projects, we mainly clean any built WASM files
            let dist_path = std::path::Path::new(&project).join("dist");
            if dist_path.exists() {
                match std::fs::remove_dir_all(&dist_path) {
                    Ok(_) => println!("‚úÖ Cleaned dist directory"),
                    Err(e) => println!("‚ö†Ô∏è  Failed to clean dist directory: {e}"),
                }
            }

            println!("‚úÖ Project cleaned successfully!");
        }

        Commands::Info => {
            print_header();
            println!("üîß Plugin Information");
            println!("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            let plugin_info = plugin.info();
            println!("Name: {}", plugin_info.name);
            println!("Version: {}", plugin_info.version);
            println!("Description: {}", plugin_info.description);
            println!("Author: {}", plugin_info.author);

            println!();
            println!("üéØ Capabilities");
            println!("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            println!("‚úÖ Standard WASM compilation");
            println!("‚úÖ TinyGo integration");
            println!("‚úÖ Multiple optimization levels");
            println!("‚úÖ Go module support");
            println!();

            println!("üìÑ Usage");
            println!("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            println!("Primary (via Wasmrun):");
            println!("   wasmrun run ./my-go-project");
            println!("   wasmrun compile ./my-project --optimization size");
            println!();
            println!("Standalone (testing/development):");
            println!("   {} run ./my-project", env!("CARGO_PKG_NAME"));
            println!(
                "   {} compile ./my-project --target webapp",
                env!("CARGO_PKG_NAME")
            );
            println!("   {} inspect ./my-project", env!("CARGO_PKG_NAME"));
        }

        Commands::Frameworks => {
            print_header();
            println!("üåê Supported Frameworks & Project Types");
            println!("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            println!();

            println!("üì¶ Project Types:");
            println!("   ‚Ä¢ Standard WASM    - Basic Go ‚Üí WebAssembly compilation via TinyGo");
            println!("   ‚Ä¢ Web Applications - Full Go web apps compiled to WebAssembly");
            println!();

            println!("üîß Build Tools:");
            println!("   ‚Ä¢ TinyGo           - Primary WebAssembly compiler for Go");
            println!("   ‚Ä¢ go               - Standard Go toolchain for dependency management");
            println!();

            println!("üéØ Optimization Levels:");
            println!("   ‚Ä¢ debug            - Fast compilation, debug symbols");
            println!("   ‚Ä¢ release          - Balanced optimization");
            println!("   ‚Ä¢ size             - Smallest possible output");
        }
    }

    Ok(())
}

#[cfg(not(feature = "cli"))]
fn main() {
    println!("Wasmrun Go Plugin v{}", env!("CARGO_PKG_VERSION"));
    println!("This plugin is designed to be used with the Wasmrun WebAssembly runtime.");
    println!("Configuration is stored in Cargo.toml [package.metadata.wasm-plugin] section.");
    println!();
    println!("Install the CLI feature to use this binary standalone:");
    println!("  cargo install wasmgo --features cli");
    println!();
    println!("Or use with Wasmrun:");
    println!("  wasmrun plugin install wasmgo");
    println!("  wasmrun run ./my-go-project");
}
